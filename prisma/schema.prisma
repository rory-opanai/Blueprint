generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  AD
  SE
  SA
  MANAGER
}

enum TasStatus {
  EMPTY
  MANUAL
  SUGGESTED
  CONFIRMED
  STALE
  CONTRADICTION
}

enum SuggestionStatus {
  PENDING
  ACCEPTED
  EDITED_ACCEPTED
  REJECTED
}

enum RiskSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum ConnectorProvider {
  salesforce
  gmail
  slack
  gong
  gtm_agent
}

enum ConnectorAccountStatus {
  connected
  expired
  error
  disconnected
}

enum EvidenceVisibility {
  OWNER_ONLY
  MANAGER_SUMMARY
}

enum IngestionRunStatus {
  PROCESSING
  COMPLETED
  FAILED
}

enum IngestionDeltaStatus {
  PENDING
  ACCEPTED
  EDITED_ACCEPTED
  REJECTED
}

model User {
  id            String                    @id @default(cuid())
  name          String?
  email         String?                   @unique
  emailVerified DateTime?
  image         String?
  role          UserRole                  @default(AD)
  accounts      Account[]
  sessions      Session[]

  connectorAccounts      ConnectorAccount[]
  connectorHealth        ConnectorHealth[]
  slackSubscriptions     SlackChannelSubscription[]
  connectorOauthStates   ConnectorOauthState[]
  manualDeals            ManualDeal[]
  slackDealUpdates       SlackDealUpdate[]
  manualTasAnswers       ManualTasAnswer[]
  ingestionRuns          IngestionRun[]
  ingestionDecisions     IngestionDelta[]
}

model Account {
  id                 String  @id @default(cuid())
  userId             String
  type               String
  provider           String
  providerAccountId  String
  refresh_token      String?
  access_token       String?
  expires_at         Int?
  token_type         String?
  scope              String?
  id_token           String?
  session_state      String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@unique([identifier, token])
}

model ConnectorAccount {
  id               String                 @id @default(cuid())
  userId           String
  provider         ConnectorProvider
  status           ConnectorAccountStatus @default(disconnected)
  scopes           Json?
  externalUserId   String?
  externalTenantId String?
  lastCheckedAt    DateTime?
  lastError        String?
  createdAt        DateTime               @default(now())
  updatedAt        DateTime               @updatedAt

  user               User                       @relation(fields: [userId], references: [id], onDelete: Cascade)
  credential         ConnectorCredential?
  slackSubscriptions SlackChannelSubscription[]

  @@unique([userId, provider])
}

model ConnectorCredential {
  id                 String   @id @default(cuid())
  connectorAccountId String   @unique
  accessTokenEnc     String?
  refreshTokenEnc    String?
  apiKeyEnc          String?
  apiSecretEnc       String?
  metadata           Json?
  expiresAt          DateTime?
  encryptionVersion  Int      @default(1)
  rotatedAt          DateTime?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  connectorAccount ConnectorAccount @relation(fields: [connectorAccountId], references: [id], onDelete: Cascade)
}

model SlackChannelSubscription {
  id                 String   @id @default(cuid())
  userId             String
  connectorAccountId String
  channelId          String
  channelName        String?
  isActive           Boolean  @default(true)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  user             User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  connectorAccount ConnectorAccount @relation(fields: [connectorAccountId], references: [id], onDelete: Cascade)

  @@unique([userId, channelId])
}

model ConnectorOauthState {
  id           String            @id @default(cuid())
  userId       String
  provider     ConnectorProvider
  stateHash    String            @unique
  redirectUri  String
  pkceVerifier String?
  expiresAt    DateTime
  createdAt    DateTime          @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model ManualDeal {
  id                  String   @id @default(cuid())
  userId              String
  accountName         String
  opportunityName     String
  stage               String
  amount              Decimal  @db.Decimal(18, 2)
  closeDate           DateTime
  ownerName           String
  ownerEmail          String
  sourceOpportunityId String?
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  tasAnswers     ManualTasAnswer[]
  ingestionRuns  IngestionRun[]
  ingestionDeltas IngestionDelta[]

  @@index([userId, ownerEmail])
}

model ManualTasAnswer {
  id           String   @id @default(cuid())
  dealId        String
  userId        String
  questionId    String
  answer        String
  status        TasStatus @default(MANUAL)
  evidenceLinks Json?
  updatedBy     String?
  updatedAt     DateTime @updatedAt
  createdAt     DateTime @default(now())

  deal ManualDeal @relation(fields: [dealId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([dealId, questionId])
  @@index([userId, dealId])
}

model IngestionRun {
  id            String             @id @default(cuid())
  dealId         String
  submittedBy    String
  sourceType     String             @default("pasted_context")
  rawContextEnc  String
  status         IngestionRunStatus @default(PROCESSING)
  model          String
  errorMessage   String?
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @updatedAt

  deal      ManualDeal         @relation(fields: [dealId], references: [id], onDelete: Cascade)
  submitter User               @relation(fields: [submittedBy], references: [id], onDelete: Cascade)
  snapshots IngestionSnapshot[]
  deltas    IngestionDelta[]

  @@index([dealId, createdAt])
}

model IngestionSnapshot {
  id         String   @id @default(cuid())
  runId      String
  version    Int
  parsedJson Json
  createdAt  DateTime @default(now())

  run IngestionRun @relation(fields: [runId], references: [id], onDelete: Cascade)

  @@unique([runId, version])
  @@index([runId])
}

model IngestionDelta {
  id            String              @id @default(cuid())
  runId         String
  dealId        String
  questionId    String
  oldValue      String?
  proposedValue String
  confidence    Float
  evidence      Json?
  reasoning     String
  status        IngestionDeltaStatus @default(PENDING)
  decidedBy     String?
  decidedAt     DateTime?
  createdAt     DateTime             @default(now())
  updatedAt     DateTime             @updatedAt

  run      IngestionRun @relation(fields: [runId], references: [id], onDelete: Cascade)
  deal     ManualDeal   @relation(fields: [dealId], references: [id], onDelete: Cascade)
  decider  User?        @relation(fields: [decidedBy], references: [id], onDelete: SetNull)

  @@index([dealId, status, createdAt])
}

model SlackDealUpdate {
  id              String   @id @default(cuid())
  eventId         String?
  userId          String
  channelId       String
  messageTs       String
  threadTs        String?
  slackUserId     String?
  text            String
  permalink       String
  opportunityId   String?
  accountName     String?
  opportunityName String?
  createdAt       DateTime
  updatedAt       DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([channelId, messageTs])
  @@index([userId, opportunityId])
  @@index([channelId, threadTs])
  @@index([eventId])
}

model OpportunityCache {
  id                String              @id
  accountName       String
  opportunityName   String
  stage             String
  amount            Decimal             @db.Decimal(18, 2)
  closeDate         DateTime
  ownerAd           String
  ownerSe           String?
  ownerSa           String?
  nextActionOwner   String?
  nextActionDueDate DateTime?
  sfLastSyncedAt    DateTime?
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  tasQuestions      TasQuestionState[]
  suggestions       SuggestionDelta[]
  commitments       Commitment[]
  audits            AuditRun[]
  sourceMappings    SourceMappingConfirmation[]
}

model BlueprintSnapshot {
  id            String   @id @default(cuid())
  opportunityId String
  version       Int
  reason        String
  payload       Json
  createdBy     String
  createdAt     DateTime @default(now())

  @@unique([opportunityId, version])
}

model TasQuestionState {
  id               String           @id @default(cuid())
  opportunityId    String
  questionId       String
  sectionId        String
  status           TasStatus        @default(EMPTY)
  canonicalAnswer  String?
  provenanceType   String?
  provenanceBy     String?
  provenanceAt     DateTime?
  isEvidenceBacked Boolean          @default(false)
  freshnessDays    Int              @default(0)
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  opportunity      OpportunityCache @relation(fields: [opportunityId], references: [id], onDelete: Cascade)
  evidence         EvidencePointer[]

  @@unique([opportunityId, questionId])
}

model EvidencePointer {
  id              String             @id @default(cuid())
  opportunityId   String
  questionStateId String?
  sourceType      String
  sourceId        String
  deepLink        String
  excerpt         String?
  capturedAt      DateTime
  confidence      Float?
  visibility      EvidenceVisibility @default(MANAGER_SUMMARY)
  createdAt       DateTime           @default(now())
  questionState   TasQuestionState?  @relation(fields: [questionStateId], references: [id], onDelete: SetNull)
}

model SuggestionDelta {
  id               String           @id @default(cuid())
  opportunityId    String
  tasQuestionId    String
  proposedAnswer   String
  confidence       Float
  reasoningSummary String
  status           SuggestionStatus @default(PENDING)
  rejectedReason   String?
  createdAt        DateTime         @default(now())
  decidedAt        DateTime?
  decidedBy        String?
  opportunity      OpportunityCache @relation(fields: [opportunityId], references: [id], onDelete: Cascade)
  evidence         SuggestionEvidence[]
}

model SuggestionEvidence {
  id           String          @id @default(cuid())
  suggestionId String
  deepLink     String
  sourceType   String
  sourceId     String
  excerpt      String?
  suggestion   SuggestionDelta @relation(fields: [suggestionId], references: [id], onDelete: Cascade)
}

model ReviewActionLog {
  id             String   @id @default(cuid())
  suggestionId   String
  opportunityId  String
  action         String
  actor          String
  notes          String?
  idempotencyKey String
  createdAt      DateTime @default(now())

  @@unique([idempotencyKey])
}

model AuditRun {
  id                  String           @id @default(cuid())
  opportunityId       String
  stage               String
  completionPct       Float
  evidenceCoveragePct Float
  criticalGapCount    Int
  contradictionCount  Int
  staleCount          Int
  riskSeverity        RiskSeverity
  findings            Json
  createdAt           DateTime         @default(now())
  opportunity         OpportunityCache @relation(fields: [opportunityId], references: [id], onDelete: Cascade)
}

model SourceMappingConfirmation {
  id            String           @id @default(cuid())
  opportunityId String
  sourceType    String
  sourceRef     String
  confidence    Float
  confirmed     Boolean          @default(false)
  confirmedBy   String?
  confirmedAt   DateTime?
  createdAt     DateTime         @default(now())
  opportunity   OpportunityCache @relation(fields: [opportunityId], references: [id], onDelete: Cascade)
}

model ConnectorHealth {
  id             String            @id @default(cuid())
  userId         String
  connectorType  ConnectorProvider
  status         String
  lastIngestedAt DateTime?
  details        String?
  updatedAt      DateTime          @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, connectorType])
}

model Commitment {
  id               String           @id @default(cuid())
  opportunityId    String
  title            String
  owner            String
  dueDate          DateTime
  status           String
  source           String
  salesforceTaskId String?
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  opportunity      OpportunityCache @relation(fields: [opportunityId], references: [id], onDelete: Cascade)
}
